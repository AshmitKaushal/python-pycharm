# The error that occurred at runtime is know as an exception.
# The mechanism that handles error at runtime is called exception handling.
import sys

# The BaseException is the parent/root class of all exceptions classes.
# It is not directly recommended that catching BaseException bcz it includes
# system-exiting exceptions like SystemExit, KeyboardInterrupt, and GeneratorExit, among others.

# Instead, Python programmers typically catch more specific exceptions or subclass Exception,
# which is a more common base class for user-defined exceptions and application-specific error handling.
# Exception itself is a subclass of BaseException, so it inherits its properties while being more
# appropriate for general error handling in Python code.

# In python exceptions are generated by the python interpreter
# In python there is no checked and unchecked exceptions.

# What It Is:
# Raised when the user interrupts program execution, usually by pressing Ctrl+C (or equivalent on their system).

# Key Points:

# This is commonly used in command-line applications to allow the user to terminate long-running operations.
# You can catch and handle this exception to clean up or provide feedback to the user before the program exits.

# try
# The try is the block of code that contain the code that may raise an exception.
# The exception throw from try block is caught by the except block.
# For every try block there can be one or more than one except block or a finally block

# except
# The except is the block of code that contain the code that will handle the exception.

# finally
# The finally block is the always excutable block either the exception occurred or not.

# Program

try:
    print(10/0)
except ZeroDivisionError as e:
    print(e)

"""
try Block: The code inside the try block is executed. In this case, 10 / 0 causes a ZeroDivisionError 
because division by zero is not allowed in Python.

Exception Raised: When the ZeroDivisionError occurs, Python creates an exception object representing the error. 
This object contains information about the error, including a message that describes the error ("division by zero" in this case).

except ZeroDivisionError as e: The except block catches the ZeroDivisionError. 
The as e part assigns the exception object to the variable e.

Accessing the Exception Object: Inside the except block, you can use the variable e to access the exception object. 
When you print e, it calls the __str__ method of the exception object, which returns the error message.
"""

# KeyboardInterrupt
# What It Is:
# Raised when the user interrupts program execution, usually by pressing Ctrl+C (or equivalent on their system).

# Key Points:

# This is commonly used in command-line applications to allow the user to terminate long-running operations.
# You can catch and handle this exception to clean up or provide feedback to the user before the program exits.

# try:
#     while True:
#         pass
# except KeyboardInterrupt as e:
#     print(e)

try:
    print(10/0)
except ZeroDivisionError as e:
    print(e)

"""
When to Use Which?
Code 1:
Use this when you want to log or debug the exact exception details.
Ideal for developers to understand what went wrong.

Code 2:
Use this when you want to provide a user-friendly message without showing technical details.
Suitable for end-user applications where detailed error messages may confuse users.
"""


# Where Does It "Go"?
# If the exception is not assigned to a variable, Python uses an internal mechanism to manage it:

# Stored Temporarily in sys.exc_info():

# The exception object can still be accessed using the sys.exc_info() function during the except block.
# sys.exc_info() returns a tuple containing:
# The exception class.
# The exception object.
# The traceback.

print("-------------Internal mechanism-------------")
try:
    print(10/0)
except ZeroDivisionError:
    exc_type,exc_value,exc_track = sys.exc_info();
    print(exc_type)
    print(exc_value)
    print(exc_track)

try:
    print(10/0)
except:
    print("This")

#  If we dont specific the exception class after the except block
# then it catches all the exception.
# And the custom message can be printed according to us.
try:
    print(10/0)
except:
    print("Error")